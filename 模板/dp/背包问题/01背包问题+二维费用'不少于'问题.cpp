#include <iostream>
#include <cstring>

using namespace std;

const int N = 1010, M = 85;

int n, m, t;

int v1[N], v2[N], w[N];
int f[M][M];

int main()
{
    cin >> n >> m >> t;
    for (int i = 1; i <= t; ++ i) cin >> v1[i] >> v2[i] >> w[i];

    memset(f, 0x3f, sizeof f); //求最小值要把除初始状态以外的所有状态初始化为+∞
    f[0][0] = 0; //这里我们把所有j,k小于0的初始状态都合并到f[0][0][0]中来转移,也就是下面的max操作
    for (int i = 1; i <= t; ++ i)
    {
        for (int j = n; j >= 0; -- j)
        {
            for (int k = m; k >= 0; -- k)
            {
                f[j][k] = min(f[j][k], f[max(j - v1[i], 0)][max(k - v2[i], 0)] + w[i]);
            }
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
//解答：
//对比两题的思路，二维费用的背包问题，求的是不能超过体积V，重量M的情况下，能拿到价值的最大值。
//而本题是至少需要体积V，重量M的情况下，能拿到价值的最小值。就拿体积来说，至少需要多少体积，也就是说有体积比需要的体积大的物品还是能用得到，
//例如f[3][5]，至少需要3个体积，5个重量，求能拿到价值的最小值，
//现在只有一个物品，体积是4，重量是4，价值w，它说至少需要3个体积，那么体积是4还是可以用到，只是多了1个体积没用占着而已，不影响其价值。
//因此若用了这个物品，则变成了求f[0][1] + w，表示体积已经不再需求了，只需要0个体积即可
